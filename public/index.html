<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Document Viewer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding-bottom: 50px;
        }

        .header {
            background-color: #f8f9fa;
            padding: 20px 0;
            margin-bottom: 30px;
            border-bottom: 1px solid #e9ecef;
        }

        .pdf-container {
            margin-bottom: 50px;
            padding: 20px;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            background-color: #fff;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .pdf-title {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #dee2e6;
            font-weight: 600;
            color: #343a40;
        }

        .group-header {
            background-color: #e9ecef;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .pdf-canvas {
            border: 1px solid #dee2e6;
            margin: 0 auto;
            display: block;
        }

        .pdf-page-container {
            position: relative;
            margin-bottom: 30px;
        }

        .page-number {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.6) !important;
            color: white;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            z-index: 10;
        }

        .page-info {
            font-size: 0.9rem;
            color: #6c757d;
        }

        .next-page-loading {
            margin: 10px 0;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }

        .next-page-loading .spinner-border {
            width: 1.2rem;
            height: 1.2rem;
            margin-right: 10px;
        }

        .next-page-loading .loading-text {
            font-size: 0.9rem;
            margin: 0 0 0 5px;
            display: inline-block;
        }

        .page-controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 5px 0;
            background-color: #f8f9fa;
            border-radius: 5px;
            padding: 8px 15px;
        }

        .page-status {
            font-size: 0.9rem;
            color: #495057;
            line-height: 32px;
        }

        .load-more-pages {
            background-color: #6c757d;
            color: white;
            border: none;
            padding: 5px 15px;
            border-radius: 3px;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .load-more-pages:disabled {
            background-color: #adb5bd;
            cursor: not-allowed;
        }

        .group-confirmation {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background-color: #e2f0d9;
            border-radius: 5px;
            display: none;
        }

        .final-confirmation {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background-color: #d4edda;
            border-radius: 5px;
            display: none;
        }

        .loading-spinner {
            text-align: center;
            margin: 20px 0;
        }

        .btn-continue {
            background-color: #28a745;
            color: white;
        }

        .btn-sign {
            background-color: #007bff;
            color: white;
        }

        .loading-text {
            margin-top: 10px;
            font-style: italic;
            color: #6c757d;
        }

        .success-message {
            text-align: center;
            margin: 30px auto;
            padding: 30px;
            background-color: #d4edda;
            border-radius: 5px;
            max-width: 600px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            display: none;
        }

        .success-icon {
            font-size: 48px;
            color: #28a745;
            margin-bottom: 15px;
        }

        #viewer-container {
            max-width: 800px;
            margin: 0 auto;
        }

        #progress-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            z-index: 1000;
        }

        #progress-bar {
            height: 100%;
            background-color: #007bff;
            width: 0;
            transition: width 0.3s;
        }

        .document-separator {
            background-color: #f8f9fa;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
            border-left: 4px solid #007bff;
        }

        .document-title {
            margin-bottom: 5px;
            font-weight: 600;
            color: #343a40;
        }

        .document-info {
            font-size: 0.9rem;
            color: #6c757d;
        }

        .document-progress {
            font-size: 1rem;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 5px;
            position: sticky;
            top: 10px;
            z-index: 100;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .document-spacer {
            border-bottom: 1px dashed #dee2e6;
            margin: 20px 0;
        }

        .group-completion-indicator {
            background-color: #d1e7dd;
            padding: 20px;
            border-radius: 5px;
        }

        .group-completion-indicator .success-icon {
            font-size: 36px;
            color: #198754;
            margin-bottom: 10px;
        }
    </style>
</head>

<body>
    <div id="progress-container">
        <div id="progress-bar"></div>
    </div>

    <div class="header">
        <div class="container">
            <h1>Document Viewer</h1>
            <p class="lead">Review and sign your documents</p>
        </div>
    </div>

    <div class="container">
        <div id="viewer-container">
            <!-- Documents will be loaded here -->
            <div class="loading-spinner" id="initial-loading">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p class="loading-text">Loading document groups...</p>
            </div>
        </div>

        <!-- Group Confirmation Modal -->
        <div class="group-confirmation" id="group-confirmation">
            <h4>You've completed this document group</h4>
            <p>Would you like to continue to the next group?</p>
            <button id="continue-btn" class="btn btn-continue">Continue to Next Group</button>
        </div>

        <!-- Final Confirmation Modal -->
        <div class="final-confirmation" id="final-confirmation">
            <h4>You've reviewed all documents</h4>
            <p>Would you like to sign these documents?</p>
            <button id="sign-btn" class="btn btn-sign">Sign Documents</button>
        </div>

        <!-- Success Message -->
        <div class="success-message" id="success-message">
            <div class="success-icon">âœ“</div>
            <h3>Successfully Signed!</h3>
            <p>All documents have been successfully signed.</p>
            <p id="signed-timestamp" class="text-muted"></p>
            <button id="start-over-btn" class="btn btn-primary mt-3">Start Over</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Set up PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js';

        // Global variables
        let documentGroups = [];
        let currentGroupIndex = 0;
        let viewedDocuments = new Set();
        let observer;
        let signedGroups = [];

        // PDF loading config
        // All pages are loaded sequentially without pagination thresholds

        // DOM elements
        const viewerContainer = document.getElementById('viewer-container');
        const initialLoading = document.getElementById('initial-loading');
        const groupConfirmation = document.getElementById('group-confirmation');
        const finalConfirmation = document.getElementById('final-confirmation');
        const continueBtn = document.getElementById('continue-btn');
        const signBtn = document.getElementById('sign-btn');
        const successMessage = document.getElementById('success-message');
        const signedTimestamp = document.getElementById('signed-timestamp');
        const startOverBtn = document.getElementById('start-over-btn');
        const progressBar = document.getElementById('progress-bar');

        // Initialize the application
        async function initApp() {
            try {
                // Fetch document groups
                const response = await fetch('/api/document-groups');
                if (!response.ok) {
                    throw new Error('Failed to fetch document groups');
                }

                documentGroups = await response.json();
                if (documentGroups.length === 0) {
                    viewerContainer.innerHTML = '<div class="alert alert-warning">No document groups found</div>';
                    return;
                }

                // Hide loading spinner
                initialLoading.style.display = 'none';

                // Load first group
                loadGroup(0);

                // Set up intersection observer for infinite scroll
                setupIntersectionObserver();

                // Update progress bar
                updateProgressBar();
            } catch (error) {
                console.error('Error initializing app:', error);
                viewerContainer.innerHTML = `<div class="alert alert-danger">Error loading document groups: ${error.message}</div>`;
            }
        }

        // Load a specific document group
        function loadGroup(groupIndex) {
            if (groupIndex >= documentGroups.length) {
                return;
            }

            const group = documentGroups[groupIndex];

            // Create group header
            const groupHeader = document.createElement('div');
            groupHeader.className = 'group-header';
            groupHeader.id = `group-${group.groupId}`;
            groupHeader.textContent = group.groupName;
            viewerContainer.appendChild(groupHeader);

            // Create a single document container for the entire group
            createGroupDocumentContainer(group);
        }

        // Create a single document container for an entire group
        function createGroupDocumentContainer(group) {
            // Create container
            const container = document.createElement('div');
            container.className = 'pdf-container group-pdf-container';
            container.id = `container-${group.groupId}`;
            container.dataset.groupId = group.groupId;

            // Create header with document count
            const header = document.createElement('h4');
            header.className = 'pdf-title';
            header.textContent = `${group.documents.length} Documents in this Group`;
            container.appendChild(header);

            // Create canvas container
            const canvasContainer = document.createElement('div');
            canvasContainer.className = 'canvas-container';
            canvasContainer.id = `canvas-container-${group.groupId}`;
            container.appendChild(canvasContainer);

            // Create loading indicator
            const loading = document.createElement('div');
            loading.className = 'loading-spinner';
            loading.innerHTML = `
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p class="loading-text">Loading documents...</p>
            `;
            canvasContainer.appendChild(loading);

            // Add to viewer container
            viewerContainer.appendChild(container);

            // Store group documents for loading
            container._documents = group.documents;
            container._currentDocIndex = 0;
            container._groupId = group.groupId;

            // Start loading documents from the group
            loadGroupDocuments(container);
        }

        // Create container for a document
        function createDocumentContainer(docItem, groupId) {
            const container = document.createElement('div');
            container.className = 'pdf-container';
            container.id = `container-${docItem.documentId}`;
            container.dataset.documentId = docItem.documentId;
            container.dataset.groupId = groupId;

            const title = document.createElement('h4');
            title.className = 'pdf-title';
            title.textContent = docItem.title;
            container.appendChild(title);

            const canvasContainer = document.createElement('div');
            canvasContainer.className = 'canvas-container';
            canvasContainer.id = `canvas-container-${docItem.documentId}`;
            container.appendChild(canvasContainer);

            const loading = document.createElement('div');
            loading.className = 'loading-spinner';
            loading.innerHTML = `
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p class="loading-text">Loading document...</p>
            `;
            canvasContainer.appendChild(loading);

            viewerContainer.appendChild(container);

            // Load the PDF when it's in viewport
            loadPdfWhenVisible(docItem, container);
        }

        // Load PDF when container is visible in viewport
        function loadPdfWhenVisible(docItem, container) {
            const options = {
                root: null,
                rootMargin: '100px',
                threshold: 0.1
            };

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        observer.unobserve(entry.target);
                        loadPdf(docItem, container);
                    }
                });
            }, options);

            observer.observe(container);
        }        // Load PDF document
        async function loadPdf(docItem, container) {
            try {
                const canvasContainer = container.querySelector('.canvas-container');
                const loading = canvasContainer.querySelector('.loading-spinner');

                // Load the PDF document
                console.log(`Loading PDF: ${docItem.fileName}`);
                const pdfDoc = await pdfjsLib.getDocument(`/api/pdf/${docItem.fileName}`).promise;
                loading.style.display = 'none';

                console.log(`PDF loaded: ${docItem.fileName}, ${pdfDoc.numPages} pages`);

                // Create a page info element showing page count
                const pageInfo = document.createElement('div');
                pageInfo.className = 'page-info text-muted mb-3 text-center';
                pageInfo.textContent = `Total pages: ${pdfDoc.numPages}`;
                canvasContainer.appendChild(pageInfo);

                // For large documents, add page controls
                const isLargeDocument = pdfDoc.numPages > MAX_INITIAL_PAGES;

                if (isLargeDocument) {
                    console.log(`Large document detected: ${pdfDoc.numPages} pages`);
                    // Add page controls
                    const pageControls = document.createElement('div');
                    pageControls.className = 'page-controls';
                    pageControls.innerHTML = `
                        <div class="page-status">Showing pages: <span class="loaded-pages">0</span> of ${pdfDoc.numPages}</div>
                        <button class="load-more-pages">Load More Pages</button>
                    `;
                    canvasContainer.appendChild(pageControls);
                }

                // Store PDF instance in container for future reference
                container._pdfDoc = pdfDoc;
                container._currentPage = 0;
                container._totalPages = pdfDoc.numPages;
                container._isLargeDocument = isLargeDocument;
                container._loadingInProgress = false;

                // Create page container that will hold all rendered pages
                const pagesContainer = document.createElement('div');
                pagesContainer.className = 'pages-container';
                canvasContainer.appendChild(pagesContainer);

                // Create a loading indicator for subsequent pages
                const nextPageLoading = document.createElement('div');
                nextPageLoading.className = 'loading-spinner next-page-loading';
                nextPageLoading.innerHTML = `
                    <div class="spinner-border text-primary spinner-border-sm" role="status">
                        <span class="visually-hidden">Loading page...</span>
                    </div>
                    <p class="loading-text">Loading more pages...</p>
                `;
                nextPageLoading.style.display = 'none';
                canvasContainer.appendChild(nextPageLoading);

                // Store references to DOM elements
                container._pagesContainer = pagesContainer;
                container._loadingIndicator = nextPageLoading;
                container._pageStatusElement = isLargeDocument ?
                    canvasContainer.querySelector('.page-status .loaded-pages') : null;

                // For large documents, add click event to load more button
                if (isLargeDocument) {
                    const loadMoreBtn = canvasContainer.querySelector('.load-more-pages');
                    loadMoreBtn.addEventListener('click', () => {
                        console.log('Load more button clicked');
                        loadPageChunk(container);
                    });
                    container._loadMoreBtn = loadMoreBtn;
                }

                // Load initial pages (all pages for small documents, or MAX_INITIAL_PAGES for large ones)
                const initialPagesToLoad = isLargeDocument ?
                    MAX_INITIAL_PAGES : pdfDoc.numPages;

                console.log(`Loading initial ${initialPagesToLoad} pages`);

                // Load the initial pages
                await loadInitialPages(container, initialPagesToLoad);

                // Force a check for more pages after initial load for large documents
                if (isLargeDocument) {
                    setTimeout(() => {
                        checkScrollPosition(container);
                    }, 500);
                }

                // Mark document as viewed when at least one page is loaded
                viewedDocuments.add(docItem.documentId);

                // Check if all documents in the group have been viewed
                checkGroupCompletion(container.dataset.groupId);

                // Update progress
                updateProgressBar();
            } catch (error) {
                console.error('Error loading PDF:', error);
                container.innerHTML = `<div class="alert alert-danger">Error loading document: ${error.message}</div>`;
            }
        }

        // Simple observer setup - not needed for current implementation
        function setupIntersectionObserver() {
            // We're not using intersection observer with our sequential approach
        }

        // Check if all documents in a group have been viewed
        function checkGroupCompletion(groupId) {
            const group = documentGroups.find(g => g.groupId === groupId);
            if (!group) return;

            // Check if all documents in the group have been viewed
            const allDocumentsViewed = group.documents.every(doc => viewedDocuments.has(doc.documentId));

            if (allDocumentsViewed) {
                // Show group completion indicator at the bottom of the document container
                const container = document.getElementById(`container-${groupId}`);
                if (container) {
                    const completionIndicator = document.createElement('div');
                    completionIndicator.className = 'group-completion-indicator mt-4 mb-4 text-center';
                    completionIndicator.innerHTML = '<div class="success-icon">âœ“</div><h5>All documents in this group have been loaded</h5>';
                    container.appendChild(completionIndicator);

                    // Scroll to the completion indicator
                    completionIndicator.scrollIntoView({behavior: 'smooth'});
                }

                // Show group confirmation or final confirmation
                if (currentGroupIndex < documentGroups.length - 1) {
                    groupConfirmation.style.display = 'block';
                    // Scroll to confirmation
                    groupConfirmation.scrollIntoView({behavior: 'smooth'});
                } else {
                    finalConfirmation.style.display = 'block';
                    // Scroll to confirmation
                    finalConfirmation.scrollIntoView({behavior: 'smooth'});
                }

                // Add to signed groups
                if (!signedGroups.includes(groupId)) {
                    signedGroups.push(groupId);
                }
            }
        }

        // Update progress bar
        function updateProgressBar() {
            const totalDocuments = documentGroups.reduce((sum, group) => sum + group.documents.length, 0);
            const viewedCount = viewedDocuments.size;
            const percentage = (viewedCount / totalDocuments) * 100;

            progressBar.style.width = `${percentage}%`;
        }

        // Set up scroll handling for the document
        function setupScrollHandling() {
            console.log('Setting up scroll handling');

            // Use a throttled scroll handler to prevent too many events
            let scrollTimeout;
            let lastScrollPosition = window.scrollY;

            window.addEventListener('scroll', () => {
                // Only check if we've scrolled a reasonable amount
                const currentScrollPosition = window.scrollY;
                const hasScrolledSignificantly = Math.abs(currentScrollPosition - lastScrollPosition) > 50;

                if (scrollTimeout) clearTimeout(scrollTimeout);

                scrollTimeout = setTimeout(() => {
                    lastScrollPosition = currentScrollPosition;

                    // Find all PDF containers with large documents
                    const containers = document.querySelectorAll('.pdf-container');
                    containers.forEach(container => {
                        if (container._isLargeDocument && !container._loadingInProgress) {
                            checkScrollPosition(container);
                        }
                    });
                }, hasScrolledSignificantly ? 50 : 150); // Faster response for significant scrolls
            });

            // Also check when window is resized
            window.addEventListener('resize', () => {
                if (scrollTimeout) clearTimeout(scrollTimeout);

                scrollTimeout = setTimeout(() => {
                    // Find all PDF containers with large documents
                    const containers = document.querySelectorAll('.pdf-container');
                    containers.forEach(container => {
                        if (container._isLargeDocument) {
                            checkScrollPosition(container);
                        }
                    });
                }, 150);
            });
        }

        // Initialize scroll handling on page load
        window.addEventListener('load', setupScrollHandling);

        // Load initial pages of a document
        async function loadInitialPages(container, pagesToLoad) {
            try {
                container._loadingInProgress = true;

                // Show loading indicator
                if (container._loadingIndicator) {
                    container._loadingIndicator.style.display = 'block';
                }

                // Load each page up to the specified limit
                for (let pageNum = 1; pageNum <= pagesToLoad && pageNum <= container._totalPages; pageNum++) {
                    await renderPage(container, pageNum);
                    container._currentPage = pageNum;
                    updatePageStatus(container);
                }

                // Hide loading indicator
                if (container._loadingIndicator) {
                    container._loadingIndicator.style.display = 'none';
                }

                // Update load more button if needed
                if (container._isLargeDocument && container._loadMoreBtn) {
                    if (container._currentPage >= container._totalPages) {
                        container._loadMoreBtn.disabled = true;
                        container._loadMoreBtn.textContent = 'All Pages Loaded';
                    }
                }

                container._loadingInProgress = false;
                return true;
            } catch (error) {
                console.error('Error loading initial pages:', error);
                container._loadingInProgress = false;
                return false;
            }
        }

        // Check scroll position to load more pages if needed
        function checkScrollPosition(container) {
            if (container._loadingInProgress || container._currentPage >= container._totalPages) {
                return;
            }

            // Check if container is visible in viewport
            const containerRect = container.getBoundingClientRect();
            const isContainerVisible =
                containerRect.top < window.innerHeight &&
                containerRect.bottom > 0;

            if (!isContainerVisible) {
                return; // Container not in viewport, no need to check further
            }

            // Check if we're close to the bottom of the last loaded page
            if (!container._pagesContainer) return;

            const rect = container._pagesContainer.getBoundingClientRect();

            // More aggressive check - load when we still have some distance left to scroll
            const isNearBottom = rect.bottom <= window.innerHeight + SCROLL_BUFFER;

            // Also check if we're near the end of the currently loaded pages
            const lastPageContainer = container._pagesContainer.lastElementChild;
            let lastPageVisible = false;

            if (lastPageContainer) {
                const lastPageRect = lastPageContainer.getBoundingClientRect();
                lastPageVisible = lastPageRect.top < window.innerHeight + (SCROLL_BUFFER / 2);
            }

            if (isNearBottom || lastPageVisible) {
                console.log(`Loading more pages for document (${container._currentPage}/${container._totalPages})`);
                loadPageChunk(container);
            }
        }

        // Load a chunk of pages
        async function loadPageChunk(container) {
            if (container._loadingInProgress || container._currentPage >= container._totalPages) {
                return;
            }

            try {
                container._loadingInProgress = true;

                // Show loading indicator
                if (container._loadingIndicator) {
                    container._loadingIndicator.style.display = 'block';
                }

                // Calculate chunk of pages to load
                const startPage = container._currentPage + 1;
                const endPage = Math.min(startPage + PAGE_CHUNK_SIZE - 1, container._totalPages);

                // Load pages in the chunk
                for (let pageNum = startPage; pageNum <= endPage; pageNum++) {
                    await renderPage(container, pageNum);
                    container._currentPage = pageNum;
                    updatePageStatus(container);

                    // Brief pause to allow UI to update
                    await new Promise(resolve => setTimeout(resolve, 10));
                }

                // Hide loading indicator
                if (container._loadingIndicator) {
                    container._loadingIndicator.style.display = 'none';
                }

                // Update load more button status
                if (container._isLargeDocument && container._loadMoreBtn) {
                    if (container._currentPage >= container._totalPages) {
                        container._loadMoreBtn.disabled = true;
                        container._loadMoreBtn.textContent = 'All Pages Loaded';
                    }
                }

                container._loadingInProgress = false;
            } catch (error) {
                console.error('Error loading page chunk:', error);
                container._loadingInProgress = false;
            }
        }

        // Render a single page
        async function renderPage(container, pageNum) {
            try {
                // Create page container
                const pageContainer = document.createElement('div');
                pageContainer.className = 'pdf-page-container';
                pageContainer.dataset.pageNum = pageNum;

                // Add page number indicator
                const pageNumberIndicator = document.createElement('div');
                pageNumberIndicator.className = 'page-number badge bg-secondary';
                pageNumberIndicator.textContent = `Page ${pageNum}`;
                pageContainer.appendChild(pageNumberIndicator);

                // Get the page
                const page = await container._pdfDoc.getPage(pageNum);
                const viewport = page.getViewport({scale: 1.5});

                // Create canvas
                const canvas = document.createElement('canvas');
                canvas.className = 'pdf-canvas';
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                // Add canvas to page container
                pageContainer.appendChild(canvas);

                // Add page container to pages container
                container._pagesContainer.appendChild(pageContainer);

                // Render the page content
                const renderContext = {
                    canvasContext: canvas.getContext('2d'),
                    viewport: viewport
                };

                await page.render(renderContext).promise;

                return pageNum;
            } catch (error) {
                console.error(`Error rendering page ${pageNum}:`, error);
                throw error;
            }
        }

        // Update page status display
        function updatePageStatus(container) {
            if (container._pageStatusElement) {
                container._pageStatusElement.textContent = container._currentPage;
            }
        }

        // Event listeners
        continueBtn.addEventListener('click', () => {
            // Hide confirmation
            groupConfirmation.style.display = 'none';

            // Increment group index and load next group
            currentGroupIndex++;
            if (currentGroupIndex < documentGroups.length) {
                // Scroll to top of viewer container
                viewerContainer.scrollIntoView({behavior: 'smooth', block: 'start'});
                loadGroup(currentGroupIndex);
            }
        });

        signBtn.addEventListener('click', async () => {
            try {
                finalConfirmation.innerHTML = `
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Signing...</span>
                    </div>
                    <p class="loading-text">Signing documents...</p>
                `;

                // Call the sign API
                const response = await fetch('/api/sign', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({groupIds: signedGroups})
                });

                if (!response.ok) {
                    throw new Error('Failed to sign documents');
                }

                const result = await response.json();

                // Hide final confirmation
                finalConfirmation.style.display = 'none';

                // Show success message
                successMessage.style.display = 'block';
                signedTimestamp.textContent = `Signed on: ${new Date(result.signedAt).toLocaleString()}`;

                // Scroll to success message
                successMessage.scrollIntoView({behavior: 'smooth'});
            } catch (error) {
                console.error('Error signing documents:', error);
                finalConfirmation.innerHTML = `<div class="alert alert-danger">Error signing documents: ${error.message}</div>`;
            }
        });

        startOverBtn.addEventListener('click', () => {
            // Clean up resources
            cleanupPdfResources();

            // Reset all state
            currentGroupIndex = 0;
            viewedDocuments = new Set();
            signedGroups = [];

            // Clear the container
            viewerContainer.innerHTML = '';

            // Reset UI elements
            groupConfirmation.style.display = 'none';
            finalConfirmation.style.display = 'none';
            successMessage.style.display = 'none';
            initialLoading.style.display = 'block';
            progressBar.style.width = '0%';

            // Restart the app
            initApp();
        });        // Function to clean up PDF resources
        function cleanupPdfResources() {
            // With our sequential loading approach, PDFs are destroyed after each document is rendered
            // No special cleanup needed here as we handle it during the document loading process
        }

        // Initialize the app when the page loads
        window.addEventListener('DOMContentLoaded', initApp);

        // Load all documents in a group sequentially
        async function loadGroupDocuments(container) {
            try {
                const canvasContainer = container.querySelector('.canvas-container');
                const loading = canvasContainer.querySelector('.loading-spinner');

                // Create pages container to hold all pages from all documents
                const pagesContainer = document.createElement('div');
                pagesContainer.className = 'pages-container';
                canvasContainer.appendChild(pagesContainer);

                // Create progress indicator
                const progressInfo = document.createElement('div');
                progressInfo.className = 'document-progress text-muted mb-4 text-center';
                progressInfo.innerHTML = `Loading document 1 of ${container._documents.length}`;
                canvasContainer.insertBefore(progressInfo, pagesContainer);

                // Hide initial loading spinner once setup is done
                loading.style.display = 'none';

                // Load documents sequentially
                await loadNextDocument(container, canvasContainer, pagesContainer, progressInfo);
            } catch (error) {
                console.error('Error loading group documents:', error);
                container.innerHTML = `<div class="alert alert-danger">Error loading documents: ${error.message}</div>`;
            }
        }

        // Function to load the next document in the sequence
        async function loadNextDocument(container, canvasContainer, pagesContainer, progressInfo) {
            // Check if we've processed all documents in the group
            if (container._currentDocIndex >= container._documents.length) {
                // All documents loaded, show group completion
                checkGroupCompletion(container._groupId);
                return;
            }

            const docItem = container._documents[container._currentDocIndex];

            try {
                // Update progress indicator
                progressInfo.innerHTML = `Loading document ${container._currentDocIndex + 1} of ${container._documents.length}: <strong>${docItem.title}</strong>`;

                // Create document title separator
                const docSeparator = document.createElement('div');
                docSeparator.className = 'document-separator';
                docSeparator.innerHTML = `
                    <h5 class="document-title">${docItem.title}</h5>
                    <div class="document-info">Document ${container._currentDocIndex + 1} of ${container._documents.length}</div>
                `;
                pagesContainer.appendChild(docSeparator);

                // Create loading indicator for this document
                const docLoading = document.createElement('div');
                docLoading.className = 'loading-spinner doc-loading';
                docLoading.innerHTML = `
                    <div class="spinner-border text-primary spinner-border-sm" role="status">
                        <span class="visually-hidden">Loading document...</span>
                    </div>
                    <p class="loading-text">Loading ${docItem.title}...</p>
                `;
                pagesContainer.appendChild(docLoading);

                // Load the PDF document
                console.log(`Loading PDF: ${docItem.fileName}`);
                const pdfDoc = await pdfjsLib.getDocument(`/api/pdf/${docItem.fileName}`).promise;

                // Replace loading with page info
                const pageInfo = document.createElement('div');
                pageInfo.className = 'page-info text-muted mb-3';
                pageInfo.textContent = `${pdfDoc.numPages} pages in this document`;
                pagesContainer.replaceChild(pageInfo, docLoading);

                // Render all pages of this document
                for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                    // Create page container
                    const pageContainer = document.createElement('div');
                    pageContainer.className = 'pdf-page-container';
                    pageContainer.dataset.documentId = docItem.documentId;
                    pageContainer.dataset.pageNum = pageNum;

                    // Add page number indicator
                    const pageNumberIndicator = document.createElement('div');
                    pageNumberIndicator.className = 'page-number badge bg-secondary';
                    pageNumberIndicator.textContent = `Page ${pageNum}/${pdfDoc.numPages}`;
                    pageContainer.appendChild(pageNumberIndicator);

                    // Get the page
                    const page = await pdfDoc.getPage(pageNum);
                    const viewport = page.getViewport({scale: 1.5});

                    // Create canvas
                    const canvas = document.createElement('canvas');
                    canvas.className = 'pdf-canvas';
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    // Add canvas to page container
                    pageContainer.appendChild(canvas);

                    // Add page container to pages container
                    pagesContainer.appendChild(pageContainer);

                    // Render the page content
                    const renderContext = {
                        canvasContext: canvas.getContext('2d'),
                        viewport: viewport
                    };

                    await page.render(renderContext).promise;

                    // Update progress indicator
                    progressInfo.innerHTML = `Loading document ${container._currentDocIndex + 1} of ${container._documents.length}: <strong>${docItem.title}</strong> - Page ${pageNum}/${pdfDoc.numPages}`;
                }

                // Add a spacer after the document
                const spacer = document.createElement('div');
                spacer.className = 'document-spacer';
                spacer.style.height = '40px';
                pagesContainer.appendChild(spacer);

                // Mark document as viewed
                viewedDocuments.add(docItem.documentId);

                // Clean up PDF document after we're done with it
                pdfDoc.destroy();

                // Move to the next document
                container._currentDocIndex++;

                // Update progress
                updateProgressBar();

                // Schedule loading of the next document
                setTimeout(() => {
                    loadNextDocument(container, canvasContainer, pagesContainer, progressInfo);
                }, 100);

            } catch (error) {
                console.error(`Error loading document ${docItem.fileName}:`, error);

                // Create error message
                const errorMsg = document.createElement('div');
                errorMsg.className = 'alert alert-danger';
                errorMsg.textContent = `Error loading ${docItem.title}: ${error.message}`;
                pagesContainer.appendChild(errorMsg);

                // Move to the next document despite the error
                container._currentDocIndex++;

                // Continue with the next document
                setTimeout(() => {
                    loadNextDocument(container, canvasContainer, pagesContainer, progressInfo);
                }, 100);
            }
        }
    </script>
</body>

</html>